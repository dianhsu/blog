---
title: MIT 6.1810 Operating System Engineering
math: true
date: 2022-09-11 23:32:17
categories:
    - æ“ä½œç³»ç»Ÿ
tags:
    - æ“ä½œç³»ç»Ÿ
    - å®éªŒ
index_img: https://cdn.dianhsu.com/img/2023-06-07-17-54-54.jpg
---

> Reference: https://pdos.csail.mit.edu/6.1810/2022/index.html

6.1810 æ˜¯MITçš„è‘—åçš„æ“ä½œç³»ç»Ÿè¯¾ç¨‹6.828çš„åç»­ç‰ˆæœ¬ï¼Œä¸»è¦åŒºåˆ«æ˜¯6.828åŸºäºx86æŒ‡ä»¤é›†ï¼Œ6.1810åŸºäºrisc-væŒ‡ä»¤é›†ã€‚ä¹‹å‰åš6.828çš„æ—¶å€™ï¼Œå› ä¸ºå¤ªèœäº†ï¼Œå®åœ¨æ˜¯åšä¸ä¸‹å»ğŸ¥ºï¼Œä¸€åº¦å¼ƒå‘ã€‚è¶ç€æ¯•ä¸šä¹‹å‰è¿˜æœ‰å¾ˆå¤šæ—¶é—´ï¼Œå†æ¥ä¸€éï¼Œäº‰å–è¿™æ¬¡èƒ½å¤Ÿåšå®Œè¿™å¥—è¯¾ç¨‹ã€‚

# å®éªŒç¯å¢ƒè®¾ç½® 
æˆ‘å¹³å¸¸çš„å¼€å‘è®¾å¤‡æ˜¯MacBook M1ï¼ŒæŒ‰ç…§Tools[^1]ä¸­çš„macOSçš„å·¥å…·å®‰è£…æ–¹æ³•ï¼Œå®‰è£…äº†risc-vçš„cross compileç¼–è¯‘å·¥å…·ä¹‹åï¼Œå‘ç°å¹¶ä¸èƒ½ç¼–è¯‘æˆåŠŸã€‚å¤šæ¬¡å°è¯•æœªæœä¹‹åï¼Œæœæ–­æ”¾å¼ƒï¼Œé€‰æ‹©æ‹¥æŠ±è¿œç«¯ç¯å¢ƒã€‚è¿™æ¬¡å°±æ²¡æœ‰åƒä¸Šæ¬¡ä¸€æ ·ç”¨é˜¿é‡Œäº‘çš„æœåŠ¡å™¨äº†ï¼Œè¿™æ¬¡ç”¨çš„æ˜¯GitHubæä¾›çš„Codespaces[^2]ã€‚è¿™å¥—ç¯å¢ƒï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿åœ¨ä¸åŒè®¾å¤‡ä¸Šè¿›è¡Œä½¿ç”¨ï¼Œå¯ä»¥é€‰æ‹©ç”¨æœ¬åœ°çš„vscodeï¼Œä¹Ÿå¯ä»¥é€‰æ‹©ç”¨æµè§ˆå™¨ç‰ˆæœ¬çš„vscodeï¼Œè¿˜å¯ä»¥ç”¨sshè¿æ¥ç«¯å£ä½¿ç”¨vimï¼Œè¶…çº§æ–¹ä¾¿ğŸ¤£ã€‚å”¯ä¸€çš„ä¸å¥½çš„åœ°æ–¹å°±æ˜¯ç½‘ç»œå·®çš„æ—¶å€™ç”¨èµ·æ¥æœ‰ç‚¹å¡ã€‚

æŒ‰ç…§Tools[^1]ä¸­æä¾›çš„æ­¥éª¤ï¼Œåœ¨Codespaces[^2]ä¸­å®‰è£…å¿…è¦çš„ç¯å¢ƒå’Œå·¥å…·ã€‚

```bash
sudo apt-get update && sudo apt-get upgrade -y
sudo apt-get install -y git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 
```
 
# Lab: Xv6 and Unix utilities
è¿™æ˜¯ç¬¬ä¸€ä¸ªLabï¼Œä¸»è¦æ˜¯ç†Ÿæ‚‰ä¸‹ç¯å¢ƒï¼Œç„¶åç¼–å†™å‡ ä¸ªå‘½ä»¤è¡Œå°å·¥å…·ã€‚

## sleep(easy)
åœ¨xv6ä¸­å®ç°UNIXå½“ä¸­çš„sleepå‡½æ•°ã€‚

`user/sleep.c`çš„ä»£ç å®ç°å¦‚ä¸‹
```c
/*
    filename: user/sleep.c
*/

#include "kernel/types.h"
#include "user/user.h"

int main(int argc, char *argv[]){
    if(argc != 2){
        exit(0);
    }
    // atoi æ˜¯å°†å­—ç¬¦ä¸²è½¬æ¢æˆæ•°å­—ï¼Œå®šä¹‰åœ¨user/user.hä¸­
    int n = atoi(argv[1]);
    sleep(n);
    exit(0);
}
```
å®ç°å®Œæˆä¹‹åï¼Œéœ€è¦åœ¨`Makefile`æ–‡ä»¶ä¸­æ·»åŠ ä¸Šè¿™ä¸ªæ–‡ä»¶ç”Ÿæˆçš„æ‰§è¡Œæ–‡ä»¶ã€‚

```Makefile
UPROGS=\
	$U/_grind\
	$U/_wc\
	$U/_zombie\
	$U/_sleep\  # æ–°å¢æ­¤è¡Œ
```
ç„¶ååœ¨å‘½ä»¤è¡Œä¸­æ‰§è¡Œ`./grade-lab-util sleep`æ¥æ£€æŸ¥æ˜¯å¦æ­£ç¡®ã€‚

å‚è€ƒçš„commit: [https://github.com/dianhsu/xv6-riscv/commit/eee6ab6d5a3c7df8f9f0fff1ac036ae38105ab3a](https://github.com/dianhsu/xv6-riscv/commit/eee6ab6d5a3c7df8f9f0fff1ac036ae38105ab3a)
## pingpong(easy)
åœ¨xv6ä¸­å®ç°UNIXå½“ä¸­çš„pingpongå‡½æ•°ã€‚
```c
#include "kernel/types.h"
#include "user/user.h"

int main(int argc, char* argv[]){
    char buf[16];
    int p_p2c[2], p_c2p[2];
    if(pipe(p_p2c) < 0){
        exit(1);
    }
    if(pipe(p_c2p) < 0){
        exit(1);
    }
    if(fork() > 0){
        close(p_p2c[0]);
        close(p_c2p[1]);

        write(p_p2c[1], "p", 1);
        read(p_c2p[0], buf, 1); 
        fprintf(2, "%d: received pong\n", getpid());

        close(p_p2c[1]);
        close(p_c2p[0]);
        wait(0);
    }else{
        close(p_p2c[1]);
        close(p_c2p[0]);

        read(p_p2c[0], buf, 1);
        fprintf(2, "%d: received ping\n", getpid());
        write(p_c2p[1], "p", 1);

        close(p_p2c[0]);
        close(p_c2p[1]);
        exit(0);
    }

    exit(0);
}
```
å®ç°å®Œæˆä¹‹åï¼Œéœ€è¦åœ¨`Makefile`æ–‡ä»¶ä¸­æ·»åŠ ä¸Šè¿™ä¸ªæ–‡ä»¶ç”Ÿæˆçš„æ‰§è¡Œæ–‡ä»¶ã€‚

```Makefile
UPROGS=\
	$U/_grind\
	$U/_wc\
	$U/_zombie\
	$U/_sleep\  
    $U/_pingpong\ # æ–°å¢æ­¤è¡Œ
```
## primes(moderate)
```c
#include "kernel/types.h"
#include "user/user.h"
int isPrime(int v){
    for(int i = 2; i * i <= v; ++i){
        if(v % i == 0){
            return 0;
        }
    }
    return 1;
}
int main(){
    int p[2];
    int c[2];
    if(pipe(p) < 0){
        exit(1);
    }
    if(pipe(c) < 0){
        exit(1);
    }
    if(fork() > 0){
        close(p[0]);
        close(c[1]);
        char buf[8];
        for(int i = 2; i <= 35; ++i){
            buf[0] = i;
            write(p[1], buf, 1);
        }
        close(p[1]);
        while(read(c[0], buf, 1) != 0){
            fprintf(2, "prime %d\n", (int)buf[0]);
        }
        close(c[0]);
        wait(0);
    }else{
        close(p[1]);
        close(c[0]);
        char buf[8];
        while(read(p[0], buf, 1) != 0){
            int v = buf[0];
            if(isPrime(v)){
                if(fork() == 0){
                    write(c[1], buf, 1);    
                    close(c[1]);
                    exit(0);
                }
                wait(0);
            }
            if(v == 35) break;
        }
        close(p[0]);
        close(c[1]);
        exit(0);
    }
    exit(0);
}
```
## find(moderate)
```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "kernel/fs.h"
#include "user/user.h"
void checkAndShow(char* path, char* name){
    static char buf[DIRSIZ + 1];
    char *p;
    // Find first character after last slash.
    for(p=path+strlen(path); p >= path && *p != '/'; p--);
    p++;

    // Return blank-padded name.
    if(strlen(p) >= DIRSIZ) return;
    memmove(buf, p, strlen(p));
    memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
    for(int i = 0; ; ++i){
        if(p[i] == '\0' && name[i] == '\0'){
            printf("%s\n", path);
            break;
        }else if(p[i] == '\0' || name[i] == '\0'){
            break;
        }else if(p[i] != name[i]){
            break;
        }
    }
}
void find(char* program, char *path, char* name){
    char buf[512], *p;
    int fd;
    struct dirent de;
    struct stat st;
    if((fd = open(path, 0)) < 0){
        fprintf(2, "%s: cannot open %s\n", program, path);
        return;
    }
    if(fstat(fd, &st) < 0){
        fprintf(2, "%s: cannot stat %s\n", program, path);
        close(fd);
        return;
    }
    switch(st.type){
        case T_FILE:
            if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
                printf("%s: path too long\n", program);
                break;
            }
            checkAndShow(path, name);
            break;
        case T_DIR:
            if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
                printf("%s: path too long\n", program);
                break;
            }
            strcpy(buf, path);
            p = buf + strlen(buf);
            *p++ = '/';
            while(read(fd, &de, sizeof(de)) == sizeof(de)){
                if(de.inum == 0){
                    continue;
                }
                memmove(p, de.name, DIRSIZ);
                p[DIRSIZ] = 0;
                if(stat(buf, &st) < 0){
                    printf("%s: cannot stat %s\n", program, buf);
                    continue;
                }
                if(st.type == T_DIR && (p[0] == '.' && (p[1] == '\0' || (p[1] == '.' && p[2] == '\0')))){
                    continue;
                }else{
                    find(program, buf, name);
                }
            }
            break;
    }
    close(fd);
}

int main(int argc, char* argv[]){
    if(argc == 2){
        find(argv[0], ".", argv[1]);
        exit(0);
    }
    if(argc != 3){
        exit(0);
    }
    char *dir = argv[1];
    char *name = argv[2];
    find(argv[0], dir, name);
    exit(0);
}
```
## xargs(moderate)
```c
#include "kernel/param.h"
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

#define MAXLEN 1024
char *argvs[MAXARG + 1];
char buf[512];
char argBuf[MAXLEN];

int main(int argc,  char* argv[]){
    if(argc <= 1){
        exit(0);
    }
    int idx = 0;
    argvs[idx] = 0;
    while(idx + 1 < argc){
        argvs[idx] = argv[idx + 1];
        ++idx;
        argvs[idx] = 0;
    }
    int cnt = 0;
    int pos = 0;
    while((cnt = read(0, buf, sizeof(buf))) > 0){
        if(pos + cnt >= MAXLEN) exit(0);
        memmove(argBuf + pos, buf, cnt);
        pos += cnt;
    }
    for(int i = 0; i < pos; ++i){
        if(i == 0 || argBuf[i - 1] == '\0'){
            if(idx >= MAXARG) exit(0);
            argvs[idx++] = argBuf + i;
        }
        if(argBuf[i] == '\n') argBuf[i] = '\0';
    }
    int pid;
    if((pid = fork()) > 0){
        wait(0);
    }else{
        exec(argvs[0], argvs);
        exit(0);
    }
    exit(0);
}
```
# Lab: system calls

## System call tracing (moderate)
> In this assignment you will add a system call tracing feature that may help you when debugging later labs. You'll create a new trace system call that will control tracing. It should take one argument, an integer "mask", whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls `trace(1 << SYS_fork)`, where `SYS_fork` is a syscall number from `kernel/syscall.h`. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call's number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don't need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.

In this task, we are going to design a trace program in order to trace the system calls. The trace program will take one argument, an integer "mask", whose bits specify which system calls to trace. The other arguments will be the program to be traced and the arguments of traced program. For example, in the first case(`trace 32 grep hello README`), the program will trace the `read` system call, due to the `1 << SYS_read` in `kernel/syscall.h` is 32. The `grep` is the running program, `hello` and `README` will pass to `grep` as arguments. 

### Step1. Add a system call named `trace`
In `user/user.h`, we add a system call named `trace`:
```c
// other system calls
int trace(int);
// other system calls
```
and we modify `user/usys.pl` to add the system call:
```perl
entry("trace");
```
In `kernel/syscall.h`, we define a new system call named `trace`:
```c
#define SYS_trace 22
```

In `kernel/proc.h`, we add a mask flag in `struct proc`:
```c
struct proc{
    // other fields
    int mask;
}
```

In `kernel/sysproc.c`, we add the implementation of `trace`, we use `argint` to get the mask and set it to the current process:
```c
uint64
sys_trace(void)
{
  int mask;
  if(argint(0, &mask) < 0){
    return -1;
  }
  myproc()->mask = mask;
  return 0;
}
```

In `kernel/proc.c`, we modify the `fork` function, we copy the mask from the parent process to the child process:
```c
int 
fork(void){
    // other code
    np->sz = p->sz;
    np->mask = p->mask;
    // other code
}
```

Finally, we print system calls usage in `kernel/syscall.c`, and we should create a system call name array in `kernel/syscall.c`:
```c
static uint64 (*syscalls[])(void) = {
// other system calls
[SYS_trace]   sys_trace,
// other system calls
};
extern int sys_trace(void);
static char* syscall_name[] = {
"",
"fork",
"exit",
"wait",
"pipe",
"read",
"kill",
"exec",
"fstat",
"chdir",
"dup",
"getpid",
"sbrk",
"sleep",
"uptime",
"open",
"write",
"mknod",
"unlink",
"link",
"mkdir",
"close",
"trace",
};
void
syscall(void)
{
    int num;
    struct proc *p = myproc();
    num = p->trapframe->a7;
    if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
        p->trapframe->a0 = syscalls[num]();
        if((p->mask >> num) & 1){
            // if the system call is traced, print the system call name and return value.
            printf("%d: syscall %s -> %d\n", p->pid, syscall_name[num], p->trapframe->a0);
        }
    } else {
        printf("%d %s: unknown sys call %d\n",
                p->pid, p->name, num);
        p->trapframe->a0 = -1;
    }
}
```
**Commit:** [https://github.com/dianhsu/xv6-riscv/commit/25048b45071e4331a7374c75b9ef076877c56d91](https://github.com/dianhsu/xv6-riscv/commit/25048b45071e4331a7374c75b9ef076877c56d91)
# FAQs
## In Linux environment, make report error: `-Winfinite-recursion`?
solve: add `-Wno-infinite-recursion` to `Makefile`.
```Makefile
CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -Wno-infinite-recursion
```

# References
[^1]: [Tools](https://pdos.csail.mit.edu/6.1810/2022/tools.html)
[^2]: [Codespaces](https://github.com/codespaces)