---
title: MIT 6.1810 Operating System Engineering
math: true
date: 2022-09-11 23:32:17
categories:
    - æ“ä½œç³»ç»Ÿ
tags:
    - æ“ä½œç³»ç»Ÿ
    - å®éªŒ
index_img: https://cdn.dianhsu.com/img/2022-09-12-00-20-51.jpeg
---

> Reference: https://pdos.csail.mit.edu/6.1810/2022/index.html

6.1810 æ˜¯MITçš„è‘—åçš„æ“ä½œç³»ç»Ÿè¯¾ç¨‹6.828çš„åç»­ç‰ˆæœ¬ï¼Œä¸»è¦åŒºåˆ«æ˜¯6.828åŸºäºx86æŒ‡ä»¤é›†ï¼Œ6.1810åŸºäºrisc-væŒ‡ä»¤é›†ã€‚ä¹‹å‰åš6.828çš„æ—¶å€™ï¼Œå› ä¸ºå¤ªèœäº†ï¼Œå®åœ¨æ˜¯åšä¸ä¸‹å»ğŸ¥ºï¼Œä¸€åº¦å¼ƒå‘ã€‚è¶ç€æ¯•ä¸šä¹‹å‰è¿˜æœ‰å¾ˆå¤šæ—¶é—´ï¼Œå†æ¥ä¸€éï¼Œäº‰å–è¿™æ¬¡èƒ½å¤Ÿåšå®Œè¿™å¥—è¯¾ç¨‹ã€‚

# å®éªŒç¯å¢ƒè®¾ç½® 
æˆ‘å¹³å¸¸çš„å¼€å‘è®¾å¤‡æ˜¯MacBook M1ï¼ŒæŒ‰ç…§Tools[^1]ä¸­çš„macOSçš„å·¥å…·å®‰è£…æ–¹æ³•ï¼Œå®‰è£…äº†risc-vçš„cross compileç¼–è¯‘å·¥å…·ä¹‹åï¼Œå‘ç°å¹¶ä¸èƒ½ç¼–è¯‘æˆåŠŸã€‚å¤šæ¬¡å°è¯•æœªæœä¹‹åï¼Œæœæ–­æ”¾å¼ƒï¼Œé€‰æ‹©æ‹¥æŠ±è¿œç«¯ç¯å¢ƒã€‚è¿™æ¬¡å°±æ²¡æœ‰åƒä¸Šæ¬¡ä¸€æ ·ç”¨é˜¿é‡Œäº‘çš„æœåŠ¡å™¨äº†ï¼Œè¿™æ¬¡ç”¨çš„æ˜¯GitHubæä¾›çš„Codespaces[^2]ã€‚è¿™å¥—ç¯å¢ƒï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿åœ¨ä¸åŒè®¾å¤‡ä¸Šè¿›è¡Œä½¿ç”¨ï¼Œå¯ä»¥é€‰æ‹©ç”¨æœ¬åœ°çš„vscodeï¼Œä¹Ÿå¯ä»¥é€‰æ‹©ç”¨æµè§ˆå™¨ç‰ˆæœ¬çš„vscodeï¼Œè¿˜å¯ä»¥ç”¨sshè¿æ¥ç«¯å£ä½¿ç”¨vimï¼Œè¶…çº§æ–¹ä¾¿ğŸ¤£ã€‚å”¯ä¸€çš„ä¸å¥½çš„åœ°æ–¹å°±æ˜¯ç½‘ç»œå·®çš„æ—¶å€™ç”¨èµ·æ¥æœ‰ç‚¹å¡ã€‚

æŒ‰ç…§Tools[^1]ä¸­æä¾›çš„æ­¥éª¤ï¼Œåœ¨Codespaces[^2]ä¸­å®‰è£…å¿…è¦çš„ç¯å¢ƒå’Œå·¥å…·ã€‚

```bash
sudo apt-get update && sudo apt-get upgrade -y
sudo apt-get install -y git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 
```
 
# Lab: Xv6 and Unix utilities
è¿™æ˜¯ç¬¬ä¸€ä¸ªLabï¼Œä¸»è¦æ˜¯ç†Ÿæ‚‰ä¸‹ç¯å¢ƒï¼Œç„¶åç¼–å†™å‡ ä¸ªå‘½ä»¤è¡Œå°å·¥å…·ã€‚

## sleep(easy)
åœ¨xv6ä¸­å®ç°UNIXå½“ä¸­çš„sleepå‡½æ•°ã€‚

`user/sleep.c`çš„ä»£ç å®ç°å¦‚ä¸‹
```c
/*
    filename: user/sleep.c
*/

#include "kernel/types.h"
#include "user/user.h"

int main(int argc, char *argv[]){
    if(argc != 2){
        exit(0);
    }
    // atoi æ˜¯å°†å­—ç¬¦ä¸²è½¬æ¢æˆæ•°å­—ï¼Œå®šä¹‰åœ¨user/user.hä¸­
    int n = atoi(argv[1]);
    sleep(n);
    exit(0);
}
```
å®ç°å®Œæˆä¹‹åï¼Œéœ€è¦åœ¨`Makefile`æ–‡ä»¶ä¸­æ·»åŠ ä¸Šè¿™ä¸ªæ–‡ä»¶ç”Ÿæˆçš„æ‰§è¡Œæ–‡ä»¶ã€‚

```Makefile
UPROGS=\
	$U/_grind\
	$U/_wc\
	$U/_zombie\
	$U/_sleep\  # æ–°å¢æ­¤è¡Œ
```
ç„¶ååœ¨å‘½ä»¤è¡Œä¸­æ‰§è¡Œ`./grade-lab-util sleep`æ¥æ£€æŸ¥æ˜¯å¦æ­£ç¡®ã€‚

å‚è€ƒçš„commit: [https://github.com/dianhsu/xv6-riscv/commit/eee6ab6d5a3c7df8f9f0fff1ac036ae38105ab3a](https://github.com/dianhsu/xv6-riscv/commit/eee6ab6d5a3c7df8f9f0fff1ac036ae38105ab3a)
## pingpong(easy)
åœ¨xv6ä¸­å®ç°UNIXå½“ä¸­çš„pingpongå‡½æ•°ã€‚
```c
#include "kernel/types.h"
#include "user/user.h"

int main(int argc, char* argv[]){
    char buf[16];
    int p_p2c[2], p_c2p[2];
    if(pipe(p_p2c) < 0){
        exit(1);
    }
    if(pipe(p_c2p) < 0){
        exit(1);
    }
    if(fork() > 0){
        close(p_p2c[0]);
        close(p_c2p[1]);

        write(p_p2c[1], "p", 1);
        read(p_c2p[0], buf, 1); 
        fprintf(2, "%d: received pong\n", getpid());

        close(p_p2c[1]);
        close(p_c2p[0]);
        wait(0);
    }else{
        close(p_p2c[1]);
        close(p_c2p[0]);

        read(p_p2c[0], buf, 1);
        fprintf(2, "%d: received ping\n", getpid());
        write(p_c2p[1], "p", 1);

        close(p_p2c[0]);
        close(p_c2p[1]);
        exit(0);
    }

    exit(0);
}
```
å®ç°å®Œæˆä¹‹åï¼Œéœ€è¦åœ¨`Makefile`æ–‡ä»¶ä¸­æ·»åŠ ä¸Šè¿™ä¸ªæ–‡ä»¶ç”Ÿæˆçš„æ‰§è¡Œæ–‡ä»¶ã€‚

```Makefile
UPROGS=\
	$U/_grind\
	$U/_wc\
	$U/_zombie\
	$U/_sleep\  
    $U/_pingpong\ # æ–°å¢æ­¤è¡Œ
```
## primes(moderate)
```c
#include "kernel/types.h"
#include "user/user.h"
int isPrime(int v){
    for(int i = 2; i * i <= v; ++i){
        if(v % i == 0){
            return 0;
        }
    }
    return 1;
}
int main(){
    int p[2];
    int c[2];
    if(pipe(p) < 0){
        exit(1);
    }
    if(pipe(c) < 0){
        exit(1);
    }
    if(fork() > 0){
        close(p[0]);
        close(c[1]);
        char buf[8];
        for(int i = 2; i <= 35; ++i){
            buf[0] = i;
            write(p[1], buf, 1);
        }
        close(p[1]);
        while(read(c[0], buf, 1) != 0){
            fprintf(2, "prime %d\n", (int)buf[0]);
        }
        close(c[0]);
        wait(0);
    }else{
        close(p[1]);
        close(c[0]);
        char buf[8];
        while(read(p[0], buf, 1) != 0){
            int v = buf[0];
            if(isPrime(v)){
                if(fork() == 0){
                    write(c[1], buf, 1);    
                    close(c[1]);
                    exit(0);
                }
                wait(0);
            }
            if(v == 35) break;
        }
        close(p[0]);
        close(c[1]);
        exit(0);
    }
    exit(0);
}
```
## find(moderate)
```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "kernel/fs.h"
#include "user/user.h"
void checkAndShow(char* path, char* name){
    static char buf[DIRSIZ + 1];
    char *p;
    // Find first character after last slash.
    for(p=path+strlen(path); p >= path && *p != '/'; p--);
    p++;

    // Return blank-padded name.
    if(strlen(p) >= DIRSIZ) return;
    memmove(buf, p, strlen(p));
    memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
    for(int i = 0; ; ++i){
        if(p[i] == '\0' && name[i] == '\0'){
            printf("%s\n", path);
            break;
        }else if(p[i] == '\0' || name[i] == '\0'){
            break;
        }else if(p[i] != name[i]){
            break;
        }
    }
}
void find(char* program, char *path, char* name){
    char buf[512], *p;
    int fd;
    struct dirent de;
    struct stat st;
    if((fd = open(path, 0)) < 0){
        fprintf(2, "%s: cannot open %s\n", program, path);
        return;
    }
    if(fstat(fd, &st) < 0){
        fprintf(2, "%s: cannot stat %s\n", program, path);
        close(fd);
        return;
    }
    switch(st.type){
        case T_FILE:
            if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
                printf("%s: path too long\n", program);
                break;
            }
            checkAndShow(path, name);
            break;
        case T_DIR:
            if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
                printf("%s: path too long\n", program);
                break;
            }
            strcpy(buf, path);
            p = buf + strlen(buf);
            *p++ = '/';
            while(read(fd, &de, sizeof(de)) == sizeof(de)){
                if(de.inum == 0){
                    continue;
                }
                memmove(p, de.name, DIRSIZ);
                p[DIRSIZ] = 0;
                if(stat(buf, &st) < 0){
                    printf("%s: cannot stat %s\n", program, buf);
                    continue;
                }
                if(st.type == T_DIR && (p[0] == '.' && (p[1] == '\0' || (p[1] == '.' && p[2] == '\0')))){
                    continue;
                }else{
                    find(program, buf, name);
                }
            }
            break;
    }
    close(fd);
}

int main(int argc, char* argv[]){
    if(argc == 2){
        find(argv[0], ".", argv[1]);
        exit(0);
    }
    if(argc != 3){
        exit(0);
    }
    char *dir = argv[1];
    char *name = argv[2];
    find(argv[0], dir, name);
    exit(0);
}
```
## xargs(moderate)
```c
#include "kernel/param.h"
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

#define MAXLEN 1024
char *argvs[MAXARG + 1];
char buf[512];
char argBuf[MAXLEN];

int main(int argc,  char* argv[]){
    if(argc <= 1){
        exit(0);
    }
    int idx = 0;
    argvs[idx] = 0;
    while(idx + 1 < argc){
        argvs[idx] = argv[idx + 1];
        ++idx;
        argvs[idx] = 0;
    }
    int cnt = 0;
    int pos = 0;
    while((cnt = read(0, buf, sizeof(buf))) > 0){
        if(pos + cnt >= MAXLEN) exit(0);
        memmove(argBuf + pos, buf, cnt);
        pos += cnt;
    }
    for(int i = 0; i < pos; ++i){
        if(i == 0 || argBuf[i - 1] == '\0'){
            if(idx >= MAXARG) exit(0);
            argvs[idx++] = argBuf + i;
        }
        if(argBuf[i] == '\n') argBuf[i] = '\0';
    }
    int pid;
    if((pid = fork()) > 0){
        wait(0);
    }else{
        exec(argvs[0], argvs);
        exit(0);
    }
    exit(0);
}
```

# References
[^1]: [Tools](https://pdos.csail.mit.edu/6.1810/2022/tools.html)
[^2]: [Codespaces](https://github.com/codespaces)